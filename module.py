# -*- coding: utf-8 -*-
"""updated bart module 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18tmXaEp0NqK7rzBdYQpNlPs7fryPPL8x
"""



# Targeted Resume Scoring System

# Install required packages
# #pip install transformers spacy pandas scikit-learn PyPDF2 python-docx reportlab

import torch
from transformers import BartForConditionalGeneration, BartTokenizer
import re
import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import spacy
#from google.colab import files
import os
import PyPDF2
import docx
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
import datetime
import re
from pathlib import Path
import os
# Download spaCy model
# #python -m spacy download en_core_web_md

# Load spaCy model
try:
    nlp = spacy.load("en_core_web_md")
    print("SpaCy model loaded successfully#")
except:
    print("Error loading spaCy model. Attempting to download...")
    #python -m spacy download en_core_web_md
    nlp = spacy.load("en_core_web_md")
    print("SpaCy model downloaded and loaded successfully#")

class ResumeScorer:
    def __init__(self):
        # Load BART model and tokenizer for summarization
        print("Loading BART model for summarization...")
        self.tokenizer = BartTokenizer.from_pretrained('facebook/bart-large-cnn')
        self.model = BartForConditionalGeneration.from_pretrained('facebook/bart-large-cnn')
        print("Models loaded successfully#")

    def summarize_resume(self, resume_text, max_length=300, min_length=100):
        """Summarize the resume using BART model"""
        print("Generating resume summary using BART...")

        # Clean up the text
        cleaned_text = resume_text.lower()

        # Tokenize the text
        inputs = self.tokenizer(cleaned_text, return_tensors='pt', max_length=1024, truncation=True)

        # Generate summary
        summary_ids = self.model.generate(
            inputs['input_ids'],
            num_beams=4,
            min_length=min_length,
            max_length=max_length,
            early_stopping=True
        )

        # Decode the summary
        summary = self.tokenizer.decode(summary_ids[0], skip_special_tokens=True)
        print("Summary generated successfully#")
        return summary

    def extract_job_requirements(self, job_description):
        """Extract key requirements from job description"""
        # Use spaCy to process the job description
        doc = nlp(job_description)

        # Extract skills using named entity recognition and keyword matching
        skills = []

        # Common skill indicators in job descriptions
        skill_indicators = [
            "experience with", "knowledge of", "proficiency in", "familiar with",
            "skills in", "expertise in", "background in", "understanding of",
            "required", "must have", "should have", "preferred"
        ]

        # Extract sentences that likely contain requirements
        for sentence in doc.sents:
            for indicator in skill_indicators:
                if indicator in sentence.text.lower():
                    skills.append(sentence.text.strip())
                    break

        # Extract technical skills from common categories
        tech_skills = self.extract_technical_skills(job_description)

        return {
            "requirement_sentences": skills,
            "technical_skills": tech_skills
        }

    def extract_technical_skills(self, text):
        """Extract technical skills from text"""
        # Common technical skills to look for
        technical_skills = [
            # Programming languages
            'java', 'python', 'javascript', 'typescript', 'c++', 'c#', 'ruby', 'php', 'swift',
            'kotlin', 'scala', 'perl', 'golang', 'rust', 'bash', 'shell', 'html', 'css', 'sql',
            # Frameworks
            'react', 'angular', 'vue', 'node', 'express', 'django', 'flask', 'spring', 'hibernate',
            'laravel', 'symfony', 'bootstrap', 'jquery', 'd3', 'tensorflow', 'pytorch', 'keras',
            # Databases
            'mysql', 'postgresql', 'mongodb', 'cassandra', 'redis', 'oracle', 'firebase',
            'mariadb', 'sqlite', 'dynamodb', 'couchdb', 'neo4j',
            # Cloud
            'aws', 'azure', 'gcp', 'cloud', 's3', 'ec2', 'lambda', 'docker', 'kubernetes',
            'terraform', 'jenkins', 'circleci', 'travis',
            # Tools
            'git', 'github', 'gitlab', 'bitbucket', 'jira', 'confluence', 'slack', 'notion'
        ]

        found_skills = []
        for skill in technical_skills:
            if re.search(r'\b' + re.escape(skill) + r'\b', text.lower()):
                found_skills.append(skill)

        return found_skills

    def extract_experience_from_resume(self, resume_text):
        """Extract work experience details from resume"""
        # Look for experience section
        experience_section = ""

        # Try to find experience section using common headers
        exp_headers = ["experience", "work experience", "professional experience", "employment"]

        resume_lines = resume_text.split('\n')

        # Flag to indicate if we're in the experience section
        in_experience_section = False
        next_section_found = False

        for line in resume_lines:
            # Check if this is an experience section header
            if any(header.lower() in line.lower() for header in exp_headers) and not in_experience_section:
                in_experience_section = True
                continue

            # Check if we've reached another major section
            if in_experience_section and line.strip() and any(keyword in line.lower() for keyword in ["education", "skills", "projects", "certifications", "awards"]):
                if len(line) < 50:  # To ensure it's likely a header, not content
                    next_section_found = True

            # Add line to experience section if we're in it and haven't found the next section yet
            if in_experience_section and not next_section_found:
                experience_section += line + "\n"

        # If no clear experience section found, use a more general approach
        if not experience_section:
            # Look for job titles, company names, and dates
            job_title_patterns = [
                r'\b(?:senior|lead|principal|junior)?\s*(?:software|web|frontend|backend|full[-\s]stack|data)\s*(?:engineer|developer|architect)\b',
                r'\b(?:project|product|program)\s*manager\b',
                r'\b(?:data|business|systems?)\s*analyst\b',
                r'\b(?:ux|ui|user\s*experience|user\s*interface)\s*designer\b'
            ]

            date_patterns = [
                r'\b(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\.?\s*\d{4}\s*(?:-|–|to)\s*(?:present|current|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\.?\s*\d{0,4}\b',
                r'\b\d{4}\s*(?:-|–|to)\s*(?:present|current|\d{4})\b'
            ]

            for i, line in enumerate(resume_lines):
                # Check for job titles or dates
                if any(re.search(pattern, line, re.IGNORECASE) for pattern in job_title_patterns) or \
                   any(re.search(pattern, line, re.IGNORECASE) for pattern in date_patterns):
                    # Add this line and the next few lines as potential experience
                    experience_section += line + "\n"
                    for j in range(1, 6):  # Include up to 5 lines after a job title or date
                        if i + j < len(resume_lines):
                            experience_section += resume_lines[i + j] + "\n"

        # Extract years of experience
        years_of_experience = self.extract_years_of_experience(resume_text)

        return {
            "experience_text": experience_section,
            "years_of_experience": years_of_experience
        }

    def extract_years_of_experience(self, text):
        """Extract total years of experience from resume text"""
        # Look for explicit statements of years of experience
        explicit_patterns = [
            r'\b(\d+)\+?\s*(?:years|yrs)(?:\s+of)?\s+experience\b',
            r'\bexperience\s+of\s+(\d+)\+?\s*(?:years|yrs)\b'
        ]

        for pattern in explicit_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                try:
                    return int(matches[0])
                except:
                    pass

        # Try to calculate from job dates
        date_ranges = re.findall(r'\b((?:19|20)\d{2})\s*(?:-|–|to)\s*((?:19|20)\d{2}|present|current)\b', text, re.IGNORECASE)
        if date_ranges:
            total_years = 0
            import datetime
            current_year = datetime.datetime.now().year

            for start, end in date_ranges:
                start_year = int(start)
                if end.lower() in ['present', 'current']:
                    end_year = current_year
                else:
                    end_year = int(end)
                total_years += (end_year - start_year)

            return total_years

        # If no explicit years of experience found, return 0
        return 0

    def extract_education(self, resume_text):
        """Extract education information"""
        # Look for education section
        education_section = ""

        # Try to find education section using common headers
        edu_headers = ["education", "academic background", "qualifications"]

        resume_lines = resume_text.split('\n')

        # Flag to indicate if we're in the education section
        in_education_section = False
        next_section_found = False

        for line in resume_lines:
            # Check if this is an education section header
            if any(header.lower() in line.lower() for header in edu_headers) and not in_education_section:
                in_education_section = True
                continue

            # Check if we've reached another major section
            if in_education_section and line.strip() and any(keyword in line.lower() for keyword in ["experience", "skills", "projects", "certifications", "awards"]):
                if len(line) < 50:  # To ensure it's likely a header, not content
                    next_section_found = True

            # Add line to education section if we're in it and haven't found the next section yet
            if in_education_section and not next_section_found:
                education_section += line + "\n"

        # If no clear education section found, look for education keywords
        if not education_section:
            education_keywords = ['bachelor', 'master', 'phd', 'degree', 'university', 'college',
                                'b.s.', 'm.s.', 'b.a.', 'm.a.', 'b.tech', 'm.tech', 'mba']

            for i, line in enumerate(resume_lines):
                if any(keyword.lower() in line.lower() for keyword in education_keywords):
                    education_section += line + "\n"
                    # Include a few lines after an education keyword
                    for j in range(1, 3):
                        if i + j < len(resume_lines):
                            education_section += resume_lines[i + j] + "\n"

        # Check the highest degree
        degree_patterns = {
            'phd': r'\b(?:phd|ph\.d\.|doctorate|doctoral)\b',
            'masters': r'\b(?:master|masters|ms|m\.s\.|ma|m\.a\.|mba|m\.b\.a\.|m\.eng|m\.tech)\b',
            'bachelors': r'\b(?:bachelor|bachelors|bs|b\.s\.|ba|b\.a\.|b\.tech|b\.eng)\b',
            'associate': r'\b(?:associate|associates|as|a\.s\.|aa|a\.a\.)\b'
        }

        highest_degree = None

        for degree, pattern in degree_patterns.items():
            if re.search(pattern, education_section, re.IGNORECASE):
                highest_degree = degree
                break

        return {
            "education_text": education_section,
            "highest_degree": highest_degree
        }

    def score_resume_against_job(self, resume_text, job_description, job_role):
        """Score the resume against the job description"""
        # Get job requirements
        job_requirements = self.extract_job_requirements(job_description)

        # Get resume experience
        resume_experience = self.extract_experience_from_resume(resume_text)

        # Get education details
        education_details = self.extract_education(resume_text)

        # Extract technical skills from the resume
        resume_tech_skills = self.extract_technical_skills(resume_text)

        # Calculate skill match percentage
        job_skills = job_requirements["technical_skills"]
        matching_skills = [skill for skill in resume_tech_skills if skill in job_skills]
        skill_match_percentage = len(matching_skills) / max(1, len(job_skills)) * 100

        # Calculate experience match
        # First, check if the job requires a specific number of years
        job_years_required = 0
        for sentence in job_requirements["requirement_sentences"]:
            year_matches = re.findall(r'(\d+)\+?\s*(?:years|yrs)(?:\s+of)?\s+experience', sentence, re.IGNORECASE)
            if year_matches:
                try:
                    job_years_required = int(year_matches[0])
                    break
                except:
                    pass

        experience_match_percentage = 0
        if job_years_required > 0:
            experience_match_percentage = min(100, (resume_experience["years_of_experience"] / job_years_required) * 100)
        else:
            # If no specific years required, consider any experience as a match
            experience_match_percentage = 100 if resume_experience["years_of_experience"] > 0 else 50

        # Check if role title appears in experience
        role_match = 0
        role_keywords = job_role.lower().split()
        for keyword in role_keywords:
            if len(keyword) > 3 and keyword in resume_experience["experience_text"].lower():
                role_match += 1

        role_match_percentage = min(100, (role_match / max(1, len(role_keywords))) * 100)

        # Calculate education match
        education_match_percentage = 0
        # Check if job requires a specific degree
        degree_required = None
        for degree_type in ['phd', 'masters', 'bachelors', 'associate']:
            if any(re.search(r'\b' + re.escape(degree_type) + r'\b', req, re.IGNORECASE) for req in job_requirements["requirement_sentences"]):
                degree_required = degree_type
                break

        if degree_required:
            # Map degrees to numeric values for comparison
            degree_values = {
                'phd': 4,
                'masters': 3,
                'bachelors': 2,
                'associate': 1,
                None: 0
            }

            # Calculate match based on whether the candidate's degree meets or exceeds the requirement
            candidate_degree_value = degree_values.get(education_details["highest_degree"], 0)
            required_degree_value = degree_values.get(degree_required, 0)

            if candidate_degree_value >= required_degree_value:
                education_match_percentage = 100
            else:
                education_match_percentage = (candidate_degree_value / required_degree_value) * 100
        else:
            # If no specific degree is required, having any degree is a plus
            education_match_percentage = 100 if education_details["highest_degree"] else 50

        # Score calculations for each section
        scores = {
            "candidate_profile": min(10, role_match_percentage * 0.1),
            "work_experience": min(25, (experience_match_percentage * 0.25)),
            "skills_analysis": min(20, (skill_match_percentage * 0.2)),
            "education_certifications": min(15, (education_match_percentage * 0.15)),
            "achievements_impact": self.score_achievements(resume_text),
            "formatting_presentation": 10,  # Assume good formatting
            "adaptability_versatility": self.score_adaptability(resume_text),
            "cultural_fit": self.score_cultural_fit(resume_text)
        }

        # Round all scores to 1 decimal place
        scores = {k: round(v, 1) for k, v in scores.items()}

        # Calculate total score
        total_score = sum(scores.values())

        return {
            "section_scores": scores,
            "total_score": round(total_score, 1),
            "percentage_score": round((total_score / 100) * 100, 1),
            "matching_skills": matching_skills,
            "missing_skills": [skill for skill in job_skills if skill not in resume_tech_skills],
            "years_of_experience": resume_experience["years_of_experience"],
            "role_match": role_match_percentage,
            "experience_match": experience_match_percentage,
            "skill_match": skill_match_percentage,
            "education_match": education_match_percentage
        }

    def score_achievements(self, resume_text):
        """Score achievements in the resume"""
        # Look for quantifiable achievements
        achievement_patterns = [
            r'\b(?:increased|improved|enhanced|boosted|grew)\b.*?\b\d+%\b',
            r'\b(?:reduced|decreased|minimized|cut)\b.*?\b\d+%\b',
            r'\b(?:saved|generated|earned|produced)\b.*?\b\$\d+\b',
            r'\b(?:implemented|launched|delivered|developed|created)\b.*?\b(?:successfully|effectively|efficiently)\b'
        ]

        achievement_count = 0
        for pattern in achievement_patterns:
            matches = re.findall(pattern, resume_text, re.IGNORECASE)
            achievement_count += len(matches)

        # Score from 0-10 based on achievements found
        return min(10, achievement_count * 2)

    def score_adaptability(self, resume_text):
        """Score adaptability and versatility"""
        adaptability_keywords = [
            'adapt', 'flexible', 'versatile', 'learn', 'quick learner', 'agile',
            'multiple projects', 'various environments', 'diverse teams', 'different roles'
        ]

        adaptability_score = 0
        for keyword in adaptability_keywords:
            if re.search(r'\b' + re.escape(keyword) + r'\b', resume_text, re.IGNORECASE):
                adaptability_score += 1

        return min(5, adaptability_score)

    def score_cultural_fit(self, resume_text):
        """Score cultural fit indicators"""
        cultural_keywords = [
            'team', 'collaborate', 'communication', 'interpersonal', 'cooperation',
            'leadership', 'mentor', 'values', 'culture', 'community',
            'initiative', 'proactive', 'passion', 'motivated', 'driven'
        ]

        cultural_score = 0
        for keyword in cultural_keywords:
            if re.search(r'\b' + re.escape(keyword) + r'\b', resume_text, re.IGNORECASE):
                cultural_score += 0.5

        return min(5, cultural_score)

    def format_report_as_dataframe(self, report):
        """Format the report as a DataFrame for better visualization"""
        # Section scores DataFrame
        sections = list(report["section_scores"].keys())
        max_scores = [10, 25, 20, 15, 10, 10, 5, 5]
        actual_scores = [report["section_scores"][section] for section in sections]

        # Format section names for display
        display_names = [s.replace("_", " ").title() for s in sections]

        df_scores = pd.DataFrame({
            "Category": display_names,
            "Max Score": max_scores,
            "Candidate Score": actual_scores
        })

        # Add total row
        df_scores.loc[len(df_scores)] = ["Total", 100, report["total_score"]]

        return df_scores

# Function to extract text from different file types
def extract_text_from_file(file_path, file_extension):
    """Extract text content from different file types"""
    if file_extension == '.txt':
        with open(file_path, 'r', encoding='utf-8') as file:
            return file.read()
    elif file_extension == '.pdf':
        text = ""
        try:
            with open(file_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                for page_num in range(len(pdf_reader.pages)):
                    page_text = pdf_reader.pages[page_num].extract_text()
                    if page_text:
                        text += page_text
            return text
        except Exception as e:
            print(f"Error extracting text from PDF: {e}")
            return ""
    elif file_extension in ['.docx', '.doc']:
        try:
            doc = docx.Document(file_path)
            return "\n".join([paragraph.text for paragraph in doc.paragraphs])
        except Exception as e:
            print(f"Error extracting text from DOCX: {e}")
            return ""
    else:
        print(f"Unsupported file extension: {file_extension}")
        return ""

# Function to generate recommendations
def generate_recommendations(report):
    """Generate recommendations based on scores"""
    recommendations = []

    # Check for skills gaps
    if report["missing_skills"]:
        recommendations.append(f"• Add these missing skills to your resume: {', '.join(report['missing_skills'])}")

    # Check experience match
    if report["experience_match"] < 70:
        recommendations.append(f"• Highlight more relevant experience for the {report['job_role']} position")

    # Check role keyword match
    if report["role_match"] < 70:
        recommendations.append(f"• Include more terminology related to the {report['job_role']} position")

    # Check achievements
    if report["section_scores"]["achievements_impact"] < 7:
        recommendations.append("• Add more quantifiable achievements (numbers, percentages, specific results)")

    # Check adaptability
    if report["section_scores"]["adaptability_versatility"] < 3:
        recommendations.append("• Demonstrate your adaptability and willingness to learn new technologies")

    # Check cultural fit
    if report["section_scores"]["cultural_fit"] < 3:
        recommendations.append("• Emphasize teamwork, collaboration, and communication skills")

    # If no specific recommendations, give a general one
    if not recommendations:
        recommendations.append("Your resume is well-aligned with the job description. Consider adding more specific achievements.")

    return recommendations

# Function to extract employment history from resume
def extract_employment_history(report, resume_text, job_role):
    """Extract employment history from the resume text with improved detection"""
    if not resume_text:
        return ["Employment history data not available"]

    # Convert job role to lowercase for matching
    job_role_lower = job_role.lower()
    job_role_keywords = set(job_role_lower.split())

    # Prepare the lines and find experience section
    resume_lines = resume_text.split('\n')
    experience_section_lines = []
    in_experience_section = False

    # Common headers for experience sections
    exp_headers = ["experience", "work experience", "professional experience",
                  "employment", "work history", "career history"]

    # First attempt: Extract the experience section based on headers
    for i, line in enumerate(resume_lines):
        line_lower = line.lower().strip()

        # Check if this is an experience section start
        if any(header in line_lower for header in exp_headers) and not in_experience_section:
            in_experience_section = True
            continue

        # Check if we've reached the end of experience section (next major section)
        if in_experience_section and line.strip() and any(keyword in line_lower for keyword in
                                                     ["education", "skills", "projects",
                                                      "certifications", "awards", "references"]):
            if len(line.strip()) < 50:  # Likely a section header, not content
                in_experience_section = False
                break

        # Add line to experience section
        if in_experience_section:
            experience_section_lines.append(line)

    # If no clear experience section found, use a different approach
    if not experience_section_lines:
        # Look for blocks that might be job entries based on common patterns
        blocks = []
        current_block = []

        for line in resume_lines:
            if not line.strip():
                if current_block:
                    blocks.append('\n'.join(current_block))
                    current_block = []
            else:
                current_block.append(line)

        if current_block:  # Add the last block
            blocks.append('\n'.join(current_block))

        # Identify blocks that look like job entries
        for block in blocks:
            # Check for date patterns or job title keywords in the block
            has_date = re.search(r'\b(19|20)\d{2}\b', block) is not None
            has_job_title = any(title in block.lower() for title in
                              ["manager", "developer", "engineer", "analyst", "director",
                               "coordinator", "administrator", "specialist", "consultant"])

            if has_date or has_job_title:
                experience_section_lines.extend(block.split('\n'))

    # Process the experience section to extract job entries
    employment_history = []
    current_job = {"company": "", "title": "", "dates": "", "description": []}
    company_pattern = r'([A-Z][A-Za-z0-9\'\-\&\,\.\s]+?)\s*(?:[\(\|\-]|$)'
    date_pattern = r'(?:(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\.?\s*)?(?:19|20)\d{2}\s*(?:-|–|to)\s*(?:Present|Current|(?:(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\.?\s*)?(?:19|20)\d{2})?'

    for i, line in enumerate(experience_section_lines):
        line = line.strip()
        if not line:
            continue

        # Check if this line might be a new job entry header
        # Headers typically have a company name, job title, and/or dates
        is_header = False

        # Look for date pattern (strong indicator of a job header)
        date_match = re.search(date_pattern, line, re.IGNORECASE)
        if date_match:
            is_header = True
            current_job["dates"] = date_match.group(0).strip()

        # Look for capitalized company names
        company_match = re.search(company_pattern, line)
        if company_match and len(company_match.group(1).strip()) > 2:
            is_header = True
            current_job["company"] = company_match.group(1).strip()

        # Job titles often contain these keywords
        job_title_keywords = ["manager", "developer", "engineer", "analyst", "director",
                            "coordinator", "administrator", "specialist", "consultant",
                            "lead", "head", "chief", "officer", "architect"]

        # Check for job title keywords
        if any(keyword in line.lower() for keyword in job_title_keywords):
            # Try to extract the job title
            title_match = re.search(r'([A-Za-z\s]+(?:' + '|'.join(job_title_keywords) + ')[A-Za-z\s]*)',
                                  line, re.IGNORECASE)
            if title_match:
                is_header = True
                current_job["title"] = title_match.group(1).strip()

        # If this seems like a job header and we already have a job entry, save it
        if is_header and (current_job["company"] or current_job["title"]) and current_job["description"]:
            # Format the current job before starting a new one
            job_entry = ""
            if current_job["title"]:
                job_entry += current_job["title"]
            if current_job["company"]:
                if job_entry:
                    job_entry += " at "
                job_entry += current_job["company"]
            if current_job["dates"]:
                job_entry += f" ({current_job['dates']})"

            if job_entry:
                employment_history.append(job_entry)

            # Start a new job entry
            current_job = {"company": "", "title": "", "dates": "", "description": []}

            # Update the current job with info from this line
            if date_match:
                current_job["dates"] = date_match.group(0).strip()
            if company_match:
                current_job["company"] = company_match.group(1).strip()

            # Initialize title_match before using it
            title_match = None
            if any(keyword in line.lower() for keyword in job_title_keywords):
                title_match = re.search(r'([A-Za-z\s]+(?:' + '|'.join(job_title_keywords) + ')[A-Za-z\s]*)',
                                      line, re.IGNORECASE)
            if title_match:
                current_job["title"] = title_match.group(1).strip()

        # If not clearly a header, or we're still building the first job
        if not is_header or not employment_history:
            # This might be part of job description or could be title/company info
            if not current_job["title"] and not current_job["company"]:
                # Check if this could be title/company
                title_match = None
                if any(keyword in line.lower() for keyword in job_title_keywords):
                    title_match = re.search(r'([A-Za-z\s]+(?:' + '|'.join(job_title_keywords) + ')[A-Za-z\s]*)',
                                          line, re.IGNORECASE)
                    if title_match:
                        current_job["title"] = title_match.group(1).strip()

                company_match = re.search(company_pattern, line)
                if company_match and len(company_match.group(1).strip()) > 2:
                    current_job["company"] = company_match.group(1).strip()

                date_match = re.search(date_pattern, line, re.IGNORECASE)
                if date_match:
                    current_job["dates"] = date_match.group(0).strip()

            # Add to job description
            current_job["description"].append(line)

    # Don't forget to add the last job
    if current_job["company"] or current_job["title"]:
        job_entry = ""
        if current_job["title"]:
            job_entry += current_job["title"]
        if current_job["company"]:
            if job_entry:
                job_entry += " at "
            job_entry += current_job["company"]
        if current_job["dates"]:
            job_entry += f" ({current_job['dates']})"

        if job_entry:
            employment_history.append(job_entry)

    # If we didn't find any job entries, try a more aggressive approach
    if not employment_history:
        # Look for lines that might be job entries
        for line in resume_text.split('\n'):
            line = line.strip()
            if not line:
                continue

            # Check if line contains a date and either a company or job title
            has_date = re.search(r'\b(19|20)\d{2}\b', line) is not None
            has_company = re.search(company_pattern, line) is not None
            has_job_title = any(keyword in line.lower() for keyword in job_title_keywords)

            if has_date and (has_company or has_job_title):
                employment_history.append(line)

    # If we still didn't find any entries, use a final fallback approach
    if not employment_history:
        # Simply extract lines that look like they might be job-related
        for line in resume_text.split('\n'):
            line = line.strip()
            if not line or len(line) > 100:  # Skip empty lines or very long descriptions
                continue

            # Check if the line contains common job role keywords
            if any(keyword in line.lower() for keyword in job_title_keywords):
                employment_history.append(line)

    # If we still have nothing, report failure
    if not employment_history:
        employment_history = ["Could not extract detailed employment history from resume"]

    # Return the job entries, limiting to 5 for conciseness
    return employment_history[:5]

# Function to calculate relevant experience based on job role
def calculate_relevant_experience(report, resume_text, job_role):
    """Calculate relevant experience years based on job role and resume content"""
    total_years = report['years_of_experience']

    if total_years == 0:
        return {"years": 0, "percentage": 0, "explanation": "No experience found in resume"}

    # Extract job role keywords
    job_keywords = set()
    for word in job_role.lower().split():
        if len(word) > 3:  # Skip short words
            job_keywords.add(word)

    # Add related terms based on common job roles
    job_role_lower = job_role.lower()

    # Software development related terms
    if any(term in job_role_lower for term in ["developer", "engineer", "programmer", "coder"]):
        job_keywords.update(["software", "development", "programming", "coding", "application"])

        # Add specific technology keywords if present in job role
        tech_stacks = {
            "web": ["html", "css", "javascript", "react", "angular", "vue", "node", "frontend", "backend"],
            "java": ["java", "spring", "hibernate", "j2ee", "maven", "gradle"],
            "python": ["python", "django", "flask", "pandas", "numpy", "scipy"],
            "dotnet": ["c#", ".net", "asp.net", "visual studio", "vb.net"],
            "mobile": ["android", "ios", "swift", "kotlin", "react native", "flutter"],
            "database": ["sql", "mysql", "postgresql", "oracle", "mongodb", "nosql", "database"]
        }

        for stack, terms in tech_stacks.items():
            if any(term in job_role_lower for term in terms):
                job_keywords.update(terms)

    # Management related terms
    if any(term in job_role_lower for term in ["manager", "director", "lead", "head"]):
        job_keywords.update(["management", "leadership", "team", "strategy", "project", "planning"])

    # Analyst related terms
    if any(term in job_role_lower for term in ["analyst", "analytics", "analysis"]):
        job_keywords.update(["analysis", "data", "research", "reporting", "statistics", "insights"])

    # Count matching keywords in resume
    matches = 0
    for keyword in job_keywords:
        if keyword in resume_text.lower():
            matches += 1

    # Calculate relevance percentage
    if job_keywords:
        relevance_percentage = (matches / len(job_keywords)) * 100
    else:
        relevance_percentage = 0

    # Adjust based on experience match from the report
    if 'experience_match' in report:
        # Combine our calculated relevance with the existing experience match
        combined_percentage = (relevance_percentage + report['experience_match']) / 2
    else:
        combined_percentage = relevance_percentage

    # Calculate relevant years based on percentage
    relevant_years = total_years * (combined_percentage / 100)

    # Round to nearest 0.5
    relevant_years = round(relevant_years * 2) / 2

    # Cap at total years
    relevant_years = min(relevant_years, total_years)

    # Generate explanation
    if combined_percentage >= 85:
        explanation = "Highly relevant experience for this role"
    elif combined_percentage >= 60:
        explanation = "Good match with the required experience"
    elif combined_percentage >= 40:
        explanation = "Some relevant experience, but may need additional training"
    else:
        explanation = "Limited directly relevant experience for this role"

    return {
        "years": relevant_years,
        "percentage": round(combined_percentage, 1),
        "explanation": explanation
    }

# Function to create a PDF report with "10+ years" for experience over 10 years
def create_pdf_report(report, df_scores, recommendations, output_file="resume_analysis_report.pdf"):
    """Create a PDF report of the resume analysis results"""
    print(f"\nGenerating PDF report...")

    try:
        doc = SimpleDocTemplate(output_file, pagesize=letter)
        styles = getSampleStyleSheet()
        elements = []

        # Add custom styles
        title_style = ParagraphStyle(
            'TitleStyle',
            parent=styles['Heading1'],
            fontSize=18,
            alignment=1,  # Center alignment
            spaceAfter=12
        )

        subtitle_style = ParagraphStyle(
            'SubtitleStyle',
            parent=styles['Heading2'],
            fontSize=14,
            spaceAfter=10
        )

        normal_style = styles['Normal']
        normal_style.fontSize = 10

        # Title
        elements.append(Paragraph(f"Resume Analysis Report for {report['job_role']} Position", title_style))
        elements.append(Paragraph(f"Generated on {datetime.datetime.now().strftime('%B %d, %Y')}", styles['Italic']))
        elements.append(Spacer(1, 0.25*inch))

        # Overall Score
        elements.append(Paragraph(f"Overall Score: {report['total_score']}/100 ({report['percentage_score']}%)", subtitle_style))
        elements.append(Spacer(1, 0.1*inch))

        # Experience Information
        elements.append(Paragraph("Candidate Experience Profile:", subtitle_style))

        # Modified part: Display "10+ years" if experience exceeds 10 years
        years_exp = report['years_of_experience']
        if years_exp > 10:
            experience_text = "10+ years"
        else:
            experience_text = f"{years_exp} years"

        elements.append(Paragraph(f"<b>Total Years of Experience:</b> {experience_text}", normal_style))

        # Calculate relevant experience based on job role
        try:
            resume_text = report.get('full_resume_text', '')
            relevant_exp = calculate_relevant_experience(report, resume_text, report['job_role'])

            # Also format relevant experience to show "10+" if it exceeds 10 years
            relevant_years = relevant_exp['years']
            if relevant_years > 10:
                relevant_years_text = "10+ years"
            else:
                relevant_years_text = f"{relevant_years} years"

            elements.append(Paragraph(f"<b>Relevant Experience:</b> {relevant_years_text} ({relevant_exp['percentage']}% relevance)", normal_style))
            elements.append(Paragraph(f"<i>{relevant_exp['explanation']}</i>", normal_style))
        except Exception as e:
            print(f"Error calculating relevant experience: {e}")
            elements.append(Paragraph(f"<b>Relevant Experience:</b> Unable to calculate relevant experience", normal_style))

        # Extract and display employment history
        elements.append(Paragraph("<b>Employment History:</b>", normal_style))

        # Extract employment history using the improved function
        try:
            employment_history = extract_employment_history(report, resume_text, report['job_role'])

            for job in employment_history:
                elements.append(Paragraph(f"• {job}", normal_style))
        except Exception as e:
            print(f"Error extracting employment history: {e}")
            elements.append(Paragraph("• Unable to extract employment history", normal_style))

        elements.append(Spacer(1, 0.2*inch))

        # Resume Summary
        elements.append(Paragraph("Resume Summary:", subtitle_style))
        elements.append(Paragraph(report['resume_summary'], normal_style))
        elements.append(Spacer(1, 0.2*inch))

        # Section Scores Table
        elements.append(Paragraph("Section Scores:", subtitle_style))

        # Convert DataFrame to a list for the table
        table_data = [list(df_scores.columns)]  # Header row
        for row in df_scores.values:
            table_data.append([str(cell) for cell in row])

        # Create the table
        scores_table = Table(table_data, colWidths=[2.5*inch, 1*inch, 2*inch])

        # Style the table
        table_style = TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, -1), (-1, -1), colors.lightgrey),  # Total row
            ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),  # Total row
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ])

        scores_table.setStyle(table_style)
        elements.append(scores_table)
        elements.append(Spacer(1, 0.2*inch))

        # Skills Analysis
        elements.append(Paragraph("Skills Analysis:", subtitle_style))

        elements.append(Paragraph("Matching Skills:", styles['Heading4']))
        if report['matching_skills']:
            elements.append(Paragraph(", ".join(report['matching_skills']), normal_style))
        else:
            elements.append(Paragraph("No matching skills identified.", normal_style))

        elements.append(Paragraph("Missing Skills:", styles['Heading4']))
        if report['missing_skills']:
            elements.append(Paragraph(", ".join(report['missing_skills']), normal_style))
        else:
            elements.append(Paragraph("No missing skills identified.", normal_style))

        elements.append(Spacer(1, 0.1*inch))

        # Match Percentages
        elements.append(Paragraph("Match Analysis:", subtitle_style))
        # Format experience display for "10+ years" if applicable
        if years_exp > 10:
            elements.append(Paragraph(f"Experience: 10+ years (Match: {report['experience_match']:.1f}%)", normal_style))
        else:
            elements.append(Paragraph(f"Experience: {years_exp} years (Match: {report['experience_match']:.1f}%)", normal_style))

        elements.append(Paragraph(f"Role Keyword Match: {report['role_match']:.1f}%", normal_style))
        elements.append(Paragraph(f"Skills Match: {report['skill_match']:.1f}%", normal_style))
        elements.append(Spacer(1, 0.1*inch))

        # Recommendations
        elements.append(Paragraph("Recommendations:", subtitle_style))
        for recommendation in recommendations:
            elements.append(Paragraph(recommendation, normal_style))

        # Build the PDF
        doc.build(elements)
        print(f"PDF report generated successfully and saved as '{output_file}'")

        # Download the report in Google Colab
        try:
            # This will only work in Google Colab
            # files.download(output_file)
            output_path = Path(output_file)
            print(f"PDF report generated successfully and saved as '{output_path}'")
            # Check if the file exists in the specified path and print the location
            if output_path.exists():
                 print(f"Your report has been saved to: {output_path}")
            else:
                print("Error: PDF not saved successfully.")
        except:
            print(f"Report saved to {output_file}. Please download it manually.")

        return output_file
    except Exception as e:
        print(f"Error in PDF generation: {e}")
        import traceback
        traceback.print_exc()
        raise

# Function to analyze resume
def analyze_resume(resume_text, job_description, job_role):
    """Analyze a resume against a job description"""
    print("\n===== STARTING RESUME ANALYSIS =====\n")

    # Initialize the scorer
    scorer = ResumeScorer()

    # Generate a summary of the resume
    resume_summary = scorer.summarize_resume(resume_text)

    # Score the resume against the job
    report = scorer.score_resume_against_job(resume_text, job_description, job_role)
    report['resume_summary'] = resume_summary
    report['job_role'] = job_role
    report['full_resume_text'] = resume_text  # Store the full resume text for better employment extraction

    # Format scores as DataFrame
    df_scores = scorer.format_report_as_dataframe(report)

    # Generate recommendations
    recommendations = generate_recommendations(report)

    # Print results
    print("\n===== RESULTS =====\n")
    print(f"Job Role: {job_role}")
    print("\nResume Summary:")
    print(resume_summary)
    print("\nSection Scores:")
    print(df_scores)
    print(f"\nTotal Score: {report['total_score']}/100 ({report['percentage_score']}%)")

    print("\nMatching Skills:")
    if report['matching_skills']:
        print(", ".join(report['matching_skills']))
    else:
        print("No matching skills identified.")

    print("\nMissing Skills:")
    if report['missing_skills']:
        print(", ".join(report['missing_skills']))
    else:
        print("No missing skills identified.")

    # Modified to display "10+ years" if experience exceeds 10 years
    years_exp = report['years_of_experience']
    if years_exp > 10:
        print(f"\nExperience: 10+ years (Match: {report['experience_match']:.1f}%)")
    else:
        print(f"\nExperience: {years_exp} years (Match: {report['experience_match']:.1f}%)")

    print(f"Role Keyword Match: {report['role_match']:.1f}%")
    print(f"Skills Match: {report['skill_match']:.1f}%")

    print("\nRecommendations:")
    for recommendation in recommendations:
        print(recommendation)

    # Generate and offer PDF report download
    try:
        # Extract candidate name from resume - using the function defined at the top level
        candidate_name = extract_candidate_name(resume_text)

        # Format date and time
        current_datetime = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')

        # Create filename: FirstName_LastName_JobPosition_DateTime
        job_position_formatted = job_role.replace(' ', '')
        if candidate_name:
            pdf_output = f"{candidate_name}_{job_position_formatted}_{current_datetime}.pdf"
        else:
            pdf_output = f"Candidate_{job_position_formatted}_{current_datetime}.pdf"

        create_pdf_report(report, df_scores, recommendations, pdf_output)
    except Exception as e:
        print(f"Error generating PDF report: {e}")
        import traceback
        traceback.print_exc()
        print("\nContinuing without PDF report generation...")

    return report, df_scores

# Define extract_candidate_name function here to ensure it's available
def extract_candidate_name(resume_text):
    """Extract the candidate's name from the resume text"""
    if not resume_text:
        return None

    # Look for name at the beginning of the resume (common format)
    resume_lines = resume_text.split('\n')

    # Check the first few non-empty lines
    for i in range(min(10, len(resume_lines))):
        line = resume_lines[i].strip()
        if not line:
            continue

        # Names typically appear as 2-3 capitalized words at the top of the resume
        words = line.split()
        if 2 <= len(words) <= 4:
            # Check if words look like a name (capitalized, no numbers, no special chars)
            potential_name = True
            for word in words:
                if not word or not word[0].isupper() or any(char.isdigit() for char in word) or any(char in '@#$%^&*()_+={}[]|\\:;"<>,?/' for char in word):
                    potential_name = False
                    break

            if potential_name:
                # Format as FirstName_LastName
                if len(words) >= 2:
                    first_name = words[0]
                    last_name = words[-1]  # Last word is typically the last name
                    return f"{first_name}_{last_name}"

    # Alternative approach: Look for "Name:" or similar patterns
    name_patterns = [
        r'(?:^|\n)(?:Name|PERSONAL INFORMATION|CONTACT)[:\s]+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})',
        r'(?:^|\n)([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})(?:\n|$)'
    ]

    for pattern in name_patterns:
        matches = re.findall(pattern, resume_text)
        if matches:
            name_parts = matches[0].strip().split()
            if len(name_parts) >= 2:
                first_name = name_parts[0]
                last_name = name_parts[-1]
                return f"{first_name}_{last_name}"

    # If no name found
    return "Candidate"

# Main execution
print("# Targeted Resume Scoring System")

# Upload resume
print("\nUpload your resume (PDF, DOCX, or TXT format):")
resume_path = input("Resume Path: ")

# Check if the file exists
if os.path.exists(resume_path):
    print(f"File found: {resume_path}")
    # Continue with your code to process the file
    resume_file_extension = os.path.splitext(resume_path)[1].lower()
    
    # Process the resume based on its extension
    if resume_file_extension in ['.txt', '.pdf', '.docx', '.doc']:
        with open(resume_path, 'r') as file:
            resume_content = file.read()
        # Continue with the rest of the processing
    else:
        print("Error: Unsupported file type. Please upload a TXT, PDF, or DOCX file.")
else:
    print("Error: The file path does not exist. Please provide a valid path.")

# if uploaded_resume:
#     resume_file = list(uploaded_resume.keys())[0]
#     resume_file_path = resume_file

#     # Get file extension
#     _, file_extension = os.path.splitext(resume_file)
#     file_extension = file_extension.lower()

#     # Check if file type is supported
#     if file_extension not in ['.txt', '.pdf', '.docx', '.doc']:
#         print(f"Error: Unsupported file type {file_extension}. Please upload a TXT, PDF, or DOCX file.")
#     else:
#         try:
#             # Extract text from the resume file
#             resume_content = extract_text_from_file(resume_file_path, file_extension)

#             if not resume_content:
#                 print("Error: Could not extract text from the resume file.")
#             else:
#                 # Get job role first
#                 print("\nEnter job role (e.g., Java Developer, Data Scientist):")
#                 job_role = input("Job Role: ")

#                 # Then get job description
#                 print("\nEnter job description:")
#                 job_description = input("Paste job description here and press Enter when done: ")

#                 # Process with direct input method
#                 if job_description.strip() and job_role.strip():
#                     analyze_resume(resume_content, job_description, job_role)
#                 else:
#                     if not job_role.strip():
#                         print("Error: Job role cannot be empty.")
#                     if not job_description.strip():
#                         print("Error: Job description cannot be empty.")
#         except Exception as e:
#             print(f"Error processing file: {e}")
#             import traceback
#             traceback.print_exc()
# else:
#     print("Error: No resume file uploaded. Please upload a resume file.")